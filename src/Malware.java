import java.awt.EventQueue;

import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;

import java.io.FileOutputStream;
import java.util.Date;


import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.CreationHelper;
import org.apache.poi.ss.usermodel.RichTextString;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;

import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import com.google.common.collect.HashBasedTable;
import com.google.common.collect.Table;
import com.mxgraph.swing.mxGraphComponent;
import com.mxgraph.view.mxGraph;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.ComponentOrientation;
import java.awt.Dimension;

import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileFilter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.awt.event.ActionEvent;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridLayout;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;


//import de.parsemis.graph.Graph;

import javax.swing.JTextField;
import javax.swing.JTabbedPane;
import javax.swing.JComboBox;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JFileChooser;
import java.awt.Toolkit;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;



import weka.classifiers.Classifier;
import weka.classifiers.Evaluation;
import weka.classifiers.evaluation.NominalPrediction;
import weka.classifiers.rules.DecisionTable;
import weka.classifiers.trees.DecisionStump;
import weka.classifiers.trees.J48;
import weka.classifiers.bayes.BayesianLogisticRegression;
import weka.core.Attribute;
import weka.core.FastVector;
import weka.core.Instances;
import javax.swing.JTextArea;
import javax.swing.SwingConstants;
import javax.swing.JCheckBox;




public class Malware {

	private JFrame frmMalwareDetector;
	private JPanel showGraphPanel;

	/**
	 * Launch the application.
	 */
	public static void main(String[] args) {
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					Malware window = new Malware();
					window.frmMalwareDetector.setVisible(true);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
	}

	/**
	 * Create the application.
	 */
	public Malware() {
		initialize();
	}

	Table<String, String, Double> table = HashBasedTable.create();
	ArrayList<String> list = new ArrayList<>();
	static String[] allLists = null;
	////////////////////////////////////////////////
	Hashtable<String, String> featuresList = new Hashtable<String, String>();
	File[] selectedFile = null;
	double autoFrequency = 1.0;
	////////////////////////////////////////////////
//	int minimumFrequency = 1;
//	boolean isClosed = true;
//	//static Collection<Graph<?, ?>> parsedGraphs;
//	static final String[] options = new String[] { "--findPathsOnly=false",
//			"--findTreesOnly=true", "--findPathsOnly=true" };
//	int typeIndex = 0;

	////////////////////////////////////////////////
	mxGraph[] fsgraph = null;
	Object[] fsparent = null;
	ArrayList<Object> fsvertexlist = new ArrayList<>();
	ArrayList<ArrayList<Object>> fsvertexlists = new ArrayList<ArrayList<Object>>();
	////////////////////////////////////////////////
	mxGraph[] graph = new mxGraph[241];
	Object[] parent = new Object[241];
	ArrayList<Object> vertexlist = new ArrayList<>();
	ArrayList<ArrayList<Object>> vertexlists = new ArrayList<ArrayList<Object>>();

	///////////////////////////////////////////////
	private final JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
	
	GridBagConstraints gbConstraints;

    JPanel headerPanel;
    JPanel basicPanel;
    JPanel bodyPanel;
    JPanel inPanel;
    JPanel outPanel;
    JPanel namePanel;
    JPanel buttonPanel;

    JMenuBar menu;
    JMenu fileMenu;
    JMenuItem exitMenuItem;

    JLabel logoLabel;
    JLabel uniNameLabel;
    JLabel appNameLabel;
    
	private JComboBox graphComboList;
	private JComboBox<Object> fscomboList;
	private JPanel showSubGraphPanel;
	private JTextField txtFrequency;
	private JComboBox<String> comboBox;
	private JComboBox<String> comboBox_1;
	private JPanel showScanPanel;
	private JButton btnMining;
	private JComboBox<String> comboClassifiers;
	private JLabel lblFrequency;
	private JPanel ShowEvaluationPanel;
	private JTextArea textArea;
	private JButton btnLoadSubgraph;
	private JCheckBox simplePattern;
	/**
	 * Initialize the contents of the frame.
	 */
	private void initialize() {
		frmMalwareDetector = new JFrame();
		frmMalwareDetector.setIconImage(Toolkit.getDefaultToolkit().getImage("/home/amir/workspace/MalwareDetector/virus-scan-icon.png"));
		frmMalwareDetector.setTitle("TickSoft PiracyTest");
		frmMalwareDetector.setBounds(100, 100, 800, 700);
		frmMalwareDetector.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		frmMalwareDetector.getContentPane().setLayout(new BorderLayout(0, 0));
		frmMalwareDetector.getContentPane().applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
//		frmMalwareDetector.getContentPane().add(tabbedPane);
		
		
		try {
            logoLabel = new JLabel(new ImageIcon(ImageIO.read(new File("Logo.PNG")).getScaledInstance(90, 90, 30)));
        } catch (IOException e) {
            e.printStackTrace();
        }
		appNameLabel = new JLabel("TickSoft PiracyTest", JLabel.RIGHT);
        appNameLabel.setFont(new Font("Tahoma", Font.PLAIN, 14));
        appNameLabel.setForeground(Color.WHITE);

        uniNameLabel = new JLabel("آزمایشگاه آزمون و تایید نرم افزار دانشگاه شهید بهشتی", JLabel.RIGHT);
        uniNameLabel.setFont(new Font("Tahoma", Font.PLAIN, 14));
        uniNameLabel.setForeground(Color.WHITE);

        namePanel = new JPanel(new GridLayout(2, 1, 10, 10));
        namePanel.setBackground(Color.decode("#373737"));
        namePanel.applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
        namePanel.add(appNameLabel);
        namePanel.add(uniNameLabel);

        headerPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 20, 20));
        headerPanel.applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
        headerPanel.setPreferredSize(new Dimension((int) getMonitorWeight() + 1, 130));
        headerPanel.setBackground(Color.decode("#373737"));
        headerPanel.add(logoLabel);
        headerPanel.add(namePanel);
		
        bodyPanel = new JPanel(new BorderLayout(5, 5));
        bodyPanel.applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
        bodyPanel.setBackground(Color.decode("#e5e5e5"));
        
        exitMenuItem = new JMenuItem("خروج");

        exitMenuItem.setBackground(Color.decode("#0098be"));
        exitMenuItem.setFont(new Font("Tahoma", Font.PLAIN, 12));
        JMenuItem mntmOpen = new JMenuItem("انتخاب دیتاست");
        mntmOpen.setBackground(Color.decode("#0098be"));
        mntmOpen.setFont(new Font("Tahoma", Font.PLAIN, 12));
        
        fileMenu = new JMenu("فایل");
        fileMenu.setFont(new Font("Tahoma", Font.PLAIN, 12));
        fileMenu.add(mntmOpen);
        fileMenu.add(exitMenuItem);
       
       

        menu = new JMenuBar();
        menu.add(fileMenu);
        menu.applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
        menu.setSize((int)getMonitorWeight() + 1, 20);
        menu.setBackground(Color.decode("#0098be"));

        basicPanel = new JPanel(new BorderLayout());

        frmMalwareDetector.getContentPane().add(headerPanel, BorderLayout.NORTH);
        frmMalwareDetector.getContentPane().add(basicPanel);

        basicPanel.add(menu, BorderLayout.NORTH);
        basicPanel.add(bodyPanel);
        
        tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);

        bodyPanel.add(tabbedPane, BorderLayout.CENTER);
//      bodyPanel.add(buttonPanel, BorderLayout.SOUTH);
//		frmMalwareDetector.getContentPane().add(tabbedPane);
        tabbedPane.applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
        
		
        tabbedPane.setBackground(Color.decode("#373737"));
        tabbedPane.setForeground(Color.WHITE);
		
		JPanel graphPanel = new JPanel();
		tabbedPane.addTab("گراف", null, graphPanel, null);
		graphPanel.setLayout(new GridLayout(2, 1));
		graphPanel.setBackground(Color.decode("#e5e5e5"));
		
		
		JPanel createGraphPanel = new JPanel();
		graphPanel.add(createGraphPanel);
		createGraphPanel.setLayout(new BorderLayout(0, 0));
		createGraphPanel.setBackground(Color.decode("#e5e5e5"));
		
		JPanel buttonGraphPanel = new JPanel();
		createGraphPanel.add(buttonGraphPanel, BorderLayout.NORTH);
		buttonGraphPanel.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));
		buttonGraphPanel.setBackground(Color.decode("#e5e5e5"));
		buttonGraphPanel.applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
		
		JButton btnCreate = new JButton("ایجاد گراف");
		btnCreate.setBackground(Color.decode("#0098be"));
		buttonGraphPanel.add(btnCreate);
		
		JButton btnShowGraph = new JButton("نمایش گراف");
		btnShowGraph.setBackground(Color.decode("#0098be"));
		buttonGraphPanel.add(btnShowGraph);
		
		JButton btnClear = new JButton("پاک کردن");
		btnClear.setBackground(Color.decode("#0098be"));
		buttonGraphPanel.add(btnClear);
		
		graphComboList = new JComboBox();
		graphComboList.setBackground(Color.decode("#e5e5e5"));
		graphComboList.setPrototypeDisplayValue("xxxxxxxxxx");
		buttonGraphPanel.add(graphComboList);
		
		simplePattern = new JCheckBox("الگوهای ساده");
		simplePattern.setBackground(Color.decode("#e5e5e5"));
		buttonGraphPanel.add(simplePattern);
		
		showGraphPanel = new JPanel();
		createGraphPanel.add(showGraphPanel);
		showGraphPanel.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));
		showGraphPanel.setBackground(Color.decode("#e5e5e5"));
		
		JPanel subGraphPanel = new JPanel();
		graphPanel.add(subGraphPanel);
		subGraphPanel.setLayout(new BorderLayout(0, 0));
		subGraphPanel.setBackground(Color.decode("#e5e5e5"));
		
		JPanel buttonSubGraphPanel = new JPanel();
		subGraphPanel.add(buttonSubGraphPanel, BorderLayout.NORTH);
		buttonSubGraphPanel.setBackground(Color.decode("#e5e5e5"));
		buttonSubGraphPanel.applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
		
		lblFrequency = new JLabel("تکرار:");
		buttonSubGraphPanel.add(lblFrequency);
		lblFrequency.applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
		
		txtFrequency = new JTextField();
		txtFrequency.setHorizontalAlignment(SwingConstants.RIGHT);
		lblFrequency.setLabelFor(txtFrequency);
		buttonSubGraphPanel.add(txtFrequency);
		txtFrequency.setColumns(10);
		
		JButton btnSubgraph = new JButton("استخراج زیرگراف");
		buttonSubGraphPanel.add(btnSubgraph);
		btnSubgraph.setBackground(Color.decode("#0098be"));
		
		btnLoadSubgraph = new JButton("بارگذاری");
		btnLoadSubgraph.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				LoadSubGraphs();
			}
		});
		buttonSubGraphPanel.add(btnLoadSubgraph);
		btnLoadSubgraph.setBackground(Color.decode("#0098be"));
		
		JButton btnShowSubgraph = new JButton("نمایش زیرگراف");
		buttonSubGraphPanel.add(btnShowSubgraph);
		btnShowSubgraph.setBackground(Color.decode("#0098be"));
		
		JButton btnClear_1 = new JButton("پاک کردن");
		buttonSubGraphPanel.add(btnClear_1);
		btnClear_1.setBackground(Color.decode("#0098be"));
		
		fscomboList = new JComboBox<Object>();
		fscomboList.setPrototypeDisplayValue("xxxxxxxxxx");
		buttonSubGraphPanel.add(fscomboList);
		fscomboList.setBackground(Color.decode("#e5e5e5"));
		
		showSubGraphPanel = new JPanel();
		subGraphPanel.add(showSubGraphPanel);
		showSubGraphPanel.setBackground(Color.decode("#e5e5e5"));
		
				
		btnSubgraph.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				SubGraph();
			}
		});
				
				btnClear_1.addActionListener(new ActionListener() {
					public void actionPerformed(ActionEvent arg0) {
						showSubGraphPanel.removeAll();
						showSubGraphPanel.repaint();
						showSubGraphPanel.revalidate();
					}
				});
				
				btnShowSubgraph.addActionListener(new ActionListener() {
							public void actionPerformed(ActionEvent arg0) {
								showSubGraphPanel.removeAll();
				
								String[] selectedGraph = fscomboList.getSelectedItem().toString().split(" ");
								mxGraphComponent graphComponent = new mxGraphComponent(fsgraph[Integer.parseInt(selectedGraph[1])]);
								
								showSubGraphPanel.add(graphComponent);
								showSubGraphPanel.repaint();
								showSubGraphPanel.revalidate();
				
								
								System.out.println("ShowGraph: Done ");
							}
						});
						
				
				btnShowGraph.addActionListener(new ActionListener() {
					public void actionPerformed(ActionEvent arg0) {
		
						showGraphPanel.removeAll();
		
						String[] selectedGraph = graphComboList.getSelectedItem().toString().split(" ");
						mxGraphComponent graphComponent = new mxGraphComponent(graph[Integer.parseInt(selectedGraph[1])]);
						
						
						showGraphPanel.add(graphComponent);
						showGraphPanel.repaint();
						showGraphPanel.revalidate();
						
						System.out.println("ShowGraph: Done ");
					}
				});
				
				btnClear.addActionListener(new ActionListener() {
							public void actionPerformed(ActionEvent arg0) {
								showGraphPanel.removeAll();
								showGraphPanel.repaint();
								showGraphPanel.revalidate();
							}
						});
						
				
								
				btnCreate.addActionListener(new ActionListener() {
					public void actionPerformed(ActionEvent arg0) {
						CreateGraph();
					}
				});
		
		JPanel scanPanel = new JPanel();
		tabbedPane.addTab("پویش", null, scanPanel, null);
		scanPanel.setLayout(new BorderLayout(0, 0));
		scanPanel.setBackground(Color.decode("#e5e5e5"));
		
		JPanel buttonScanPanel = new JPanel();
		scanPanel.add(buttonScanPanel, BorderLayout.NORTH);
		buttonScanPanel.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));
		buttonScanPanel.setBackground(Color.decode("#e5e5e5"));
		buttonScanPanel.applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
		
		JButton btnScan = new JButton("پویش");
		buttonScanPanel.add(btnScan);
		btnScan.setBackground(Color.decode("#0098be"));
		
		JButton btnDrawChart = new JButton("نمایش نمودار");
		buttonScanPanel.add(btnDrawChart);
		btnDrawChart.setBackground(Color.decode("#0098be"));
		
		JButton btnClear_2 = new JButton("پاک کردن");
		buttonScanPanel.add(btnClear_2);
		btnClear_2.setBackground(Color.decode("#0098be"));
		
		comboBox = new JComboBox<String>();
		comboBox.setPrototypeDisplayValue("xxxxxxxxx");
		buttonScanPanel.add(comboBox);
		comboBox.setBackground(Color.decode("#e5e5e5"));
		
		comboBox_1 = new JComboBox<String>();
		comboBox_1.setPrototypeDisplayValue("xxxxxxxxx");
		buttonScanPanel.add(comboBox_1);
		comboBox_1.setBackground(Color.decode("#e5e5e5"));
		
		showScanPanel = new JPanel();
		scanPanel.add(showScanPanel, BorderLayout.CENTER);
		showScanPanel.setBackground(Color.decode("#e5e5e5"));
		
		JPanel evaluationPanel = new JPanel();
		tabbedPane.addTab("ارزیابی", null, evaluationPanel, null);
		evaluationPanel.setLayout(new BorderLayout(0, 0));
		evaluationPanel.setBackground(Color.decode("#e5e5e5"));
		
		JPanel buttonEvaluationPanel = new JPanel();
		evaluationPanel.add(buttonEvaluationPanel, BorderLayout.NORTH);
		buttonEvaluationPanel.setBackground(Color.decode("#e5e5e5"));
		buttonEvaluationPanel.applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
		
		comboClassifiers = new JComboBox<String>();
		comboClassifiers.setPrototypeDisplayValue("xxxxxxxxx");
		comboClassifiers.addItem("J48");
		comboClassifiers.addItem("DecisionTable");
		comboClassifiers.addItem("DecisionStump");
		comboClassifiers.addItem("BayesianLogisticRegression");
		
				btnMining = new JButton("ارزیابی مدل");
				btnMining.addActionListener(new ActionListener() {
					public void actionPerformed(ActionEvent arg0) {
						
						ExportArff();
						// I've commented the code as best I can, at the moment.
				        // Comments are denoted by "//" at the beginning of the line.
				        
				        BufferedReader datafile = readDataFile("Work//weka-piracy.arff");
				        
				        Instances data = null;
						try {
							data = new Instances(datafile);
						} catch (IOException e1) {
							// TODO Auto-generated catch block
							e1.printStackTrace();
						}
				        data.setClassIndex(data.numAttributes() - 1);
				        
				        // Choose a type of validation split
				        Instances[][] split = crossValidationSplit(data, 10);
				        
				        // Separate split into training and testing arrays
				        Instances[] trainingSplits = split[0];
				        Instances[] testingSplits  = split[1];
				        
				        // Choose a set of classifiers
				        Classifier[] models = {     new J48(),
				                                    new DecisionTable(),
				                                    new DecisionStump(),
				                                    new BayesianLogisticRegression() };
				        
				        // Run for each classifier model
//		        for(int j = 0; j < models.length; j++) {
				        int j = 0;
				        	switch (comboClassifiers.getSelectedItem().toString()) {
							case "J48":
								j = 0;
								break;
							case "DecisionTable":
								j = 1;
								break;
							case "DecisionStump":
								j = 2;
								break;
							case "BayesianLogisticRegression":
								j = 3;
								break;
							default:
								break;
							}
				        	

				            // Collect every group of predictions for current model in a FastVector
				            FastVector predictions = new FastVector();
				            ArrayList<Attribute> atts = new ArrayList<Attribute>();
				            
				            // For each training-testing split pair, train and test the classifier
				            for(int i = 0; i < trainingSplits.length; i++) {
				                Evaluation validation = null;
								try {
									validation = simpleClassify(models[j], trainingSplits[i], testingSplits[i]);
								} catch (Exception e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
//								atts.add(new Attribute("Attribute" + att, att));
				                predictions.appendElements(validation.predictions());
				                
				                // Uncomment to see the summary for each training-testing pair.
				                textArea.append(models[j].toString() + "\n");
//		                textArea.setText(models[j].toString() + "\n");
//				                 System.out.println(models[j].toString());
				            }
				            
				            // Calculate overall accuracy of current classifier on all splits
				            double accuracy = calculateAccuracy(predictions);
				            
				            // Print current classifier's name and accuracy in a complicated, but nice-looking way.
				            textArea.append(models[j].getClass().getSimpleName() + ": " + String.format("%.2f%%", accuracy) + "\n=====================\n");
				            System.out.println(models[j].getClass().getSimpleName() + ": " + String.format("%.2f%%", accuracy) + "\n=====================");
//		        }
				        
					}
				});
				buttonEvaluationPanel.add(btnMining);
				btnMining.setBackground(Color.decode("#0098be"));
		
		buttonEvaluationPanel.add(comboClassifiers);
		comboClassifiers.setBackground(Color.decode("#e5e5e5"));
		
		
		ShowEvaluationPanel = new JPanel();
		evaluationPanel.add(ShowEvaluationPanel, BorderLayout.CENTER);
		ShowEvaluationPanel.setBackground(Color.decode("#e5e5e5"));
		ShowEvaluationPanel.setLayout(new BorderLayout(0, 0));
		
		textArea = new JTextArea();
		textArea.setLineWrap(true);
		JScrollPane scroll = new JScrollPane (textArea, 
				   JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);

		ShowEvaluationPanel.add(scroll, BorderLayout.CENTER);

//		JPanel panel_13 = new JPanel();
//		frmMalwareDetector.getContentPane().add(panel_13, BorderLayout.SOUTH);
		
		JMenuBar menuBar = new JMenuBar();
//		frmMalwareDetector.getContentPane().add(menuBar, BorderLayout.NORTH);
		
		JMenu mnFile = new JMenu("File");
		menuBar.add(mnFile);
		
//		JMenuItem mntmOpen = new JMenuItem("Open");
//		mnFile.add(mntmOpen);
		

        exitMenuItem.addActionListener(new ActionListener() {
        	public void actionPerformed(ActionEvent arg0) {
                System.exit(0);
        	}
        });
		
		tabbedPane.addChangeListener(new ChangeListener() {
        	public void stateChanged(ChangeEvent arg0) {
        		tabbedPane.setBackgroundAt(tabbedPane.getSelectedIndex(), Color.decode("#373737"));
//        		UIManager.put("TabbedPane.selected", new Color(230, 216, 174));          
//        		SwingUtilities.updateComponentTreeUI(tabbedPane);
//        		UIManager.put("TabbedPane.selected", Color.decode("#373737") );
//        		tabbedPane.updateUI();

//		    	System.out.println(tabbedPane.getSelectedIndex() + "  " + tabbedPane.getSelectedComponent());
//		    	tabbedPane.setForegroundAt(tabbedPane.getSelectedIndex(), Color.decode("#373737"));
        	}
        });

		mntmOpen.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				JFileChooser fileChooser = new JFileChooser();
				fileChooser.setCurrentDirectory(new File(System.getProperty("user.home")));
				fileChooser.setMultiSelectionEnabled(true);
				int result = fileChooser.showDialog(frmMalwareDetector, "Open");
				System.setProperty("user.dir","");
				String curDir = System.getProperty("user.dir");
				if (result == JFileChooser.APPROVE_OPTION) {
				    selectedFile = fileChooser.getSelectedFiles();
				    for (int i =0; i<selectedFile.length;i++)
				    	System.out.println("Selected file: " + selectedFile[i].getAbsolutePath() + "\n" + selectedFile[i].getName() + "\n" + curDir + i);
				}
			}
		});

		

		btnClear_2.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				showScanPanel.removeAll();
				showScanPanel.repaint();
				showScanPanel.revalidate();
			}
		});

		

		btnDrawChart.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				showScanPanel.removeAll();
				
				String selectedItem1 = comboBox.getSelectedItem().toString();
				String selectedItem2 = comboBox_1.getSelectedItem().toString();
				if(!selectedItem1.equals(selectedItem2))
				{
					final XYSeries data1 = new XYSeries( selectedItem1 );
					final XYSeries data2 = new XYSeries( selectedItem2 );
				    final XYSeriesCollection dataset = new XYSeriesCollection( );
				    String selectedData1[] = featuresList.get(selectedItem1).split(" ");
					String selectedData2[] = featuresList.get(selectedItem2).split(" ");
					
					for (int i =0; i < selectedData1.length; i++) 
					{
						data1.add(i, Integer.parseInt(selectedData1[i]));
					}
					for (int i =0; i < selectedData2.length; i++) 
					{
						data2.add(i, Integer.parseInt(selectedData2[i]));
					}
					dataset.addSeries( data1 );                    
				    dataset.addSeries( data2 );
					
			        JFreeChart chart = ChartFactory.createXYLineChart("Result",
	                        "features", "", dataset, PlotOrientation.VERTICAL, true, true,
	                        false);

	                ChartPanel cp = new ChartPanel(chart);
	                showScanPanel.add(cp);
	                showScanPanel.repaint();
					showScanPanel.revalidate();
				}
				else if(selectedItem1.equals(selectedItem2))
				{
					final XYSeries data1 = new XYSeries( selectedItem1 );

				    final XYSeriesCollection dataset = new XYSeriesCollection( );
				    String selectedData1[] = featuresList.get(selectedItem1).split(" ");

					
					for (int i =0; i < selectedData1.length; i++) 
					{
						data1.add(i, Integer.parseInt(selectedData1[i]));
					}

					dataset.addSeries( data1 );                    

					
			        JFreeChart chart = ChartFactory.createXYLineChart("Result",
	                        "SubGraphs", "", dataset, PlotOrientation.VERTICAL, true, true,
	                        false);

	                ChartPanel cp = new ChartPanel(chart);
	                showScanPanel.add(cp);
	                showScanPanel.repaint();
					showScanPanel.revalidate();
				}
				
			}
		});

		btnScan.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				ScanFiles();
			}
			
			
		});

		
	}
	
	public void SubGraphCheck4() {
		
		
		String fileName1 = "Work//graphs.fp";
		
		String line1 = null;
		int count1 = 0;
		int maxcount = 200;
		if(maxcount < selectedFile.length)
			maxcount = selectedFile.length;
		try
		{
			FileReader fileReader = new FileReader(fileName1);
            
            BufferedReader bufferedReader = new BufferedReader(fileReader);

        	while ((line1 = bufferedReader.readLine()) != null) {
        		if(line1.startsWith("t #")) {
        			count1++;
        		}
        		
			}
        	
			bufferedReader.close();
            fileReader.close();

		}
		catch(FileNotFoundException ex) {
			System.out.println("Unable to open file '" + fileName1 + "'");               
        }
        catch(IOException ex) {
        	System.out.println("Error reading file '" + fileName1 + "'");                
        }
		
		int[] featuresCount = new int[count1];
		int[] originalFeaturesCount = new int[count1];
        
        for (int i=0;i<count1;i++) {
        	originalFeaturesCount[i]=0;
        	featuresCount[i]=0;
        }
        
        /////////////////////////////////////////////////////////////////////////////////////
        
        String[] edge = null;
		String[] vertex = null;

		
		ArrayList<ArrayList<String>> malwarevertices = new ArrayList<ArrayList<String>>();
		ArrayList<Table<String, String, Integer>> malwareedges = new ArrayList<Table<String, String, Integer>>();
		ArrayList<String> malwarevertex = new ArrayList<String>();
		Table<String, String, Integer> malwareedge = HashBasedTable.create();
		ArrayList<String> malwareXList = new ArrayList<String>();
		
        
		try
		{
			
			FileReader fileReader = new FileReader(fileName1);
            
            BufferedReader bufferedReader = new BufferedReader(fileReader);
            for(int k = 0;k<count1;k++) {
            	
            	
				
	            if((line1 = bufferedReader.readLine()) != null && line1.startsWith("t # " + k)) {
	            	malwarevertex = new ArrayList<String>();
	        		malwareedge = HashBasedTable.create();
	        		edge = null;
	        		vertex = null;
	            	originalFeaturesCount[Integer.parseInt(line1.split(" ")[2])] = Integer.parseInt(line1.split(" ")[4]);
	            	
	            	while ((line1 = bufferedReader.readLine()) != null && line1.startsWith("v ")) {		
	            		vertex = line1.split(" ");
	            		malwarevertex.add(vertex[2]);
	            	}
	            	
	            	while ((line1 != null) && line1.startsWith("e ")) {
	            		edge = line1.split(" ");
	            		malwareedge.put(malwarevertex.get(Integer.parseInt(edge[1])), malwarevertex.get(Integer.parseInt(edge[2])), Integer.parseInt(edge[3]));
	            		
	            		line1 = bufferedReader.readLine();
	            	}
	            	
		            if(line1 != null && line1.startsWith("x ")) {
		            	malwareXList.add(line1);
						line1 = bufferedReader.readLine();
		            }

		            malwarevertices.add(malwarevertex);
		            malwareedges.add(malwareedge);
	            }
	            
            }//for
	            bufferedReader.close();
	            fileReader.close();

            }
			catch(FileNotFoundException ex) {
				System.out.println("Unable to open file '" + fileName1 + "'");               
	        }
	        catch(IOException ex) {
	        	System.out.println("Error reading file '" + fileName1 + "'");                
	        }
        
        /////////////////////////////////////////////////////////////////////////////////////
		ArrayList<ArrayList<String>> benignvertices = new ArrayList<ArrayList<String>>();
		ArrayList<Table<String, String, Integer>> benignedges = new ArrayList<Table<String, String, Integer>>();
		ArrayList<String> benignvertex = new ArrayList<String>();
		Table<String, String, Integer> benignedge = HashBasedTable.create();
		ArrayList<String> benignNumbers = new ArrayList<String>();
		
		for(int l = 0;l<selectedFile.length;l++) {
			
			String[] fileName0 = selectedFile[l].getName().split("\\.");
			
			if(!fileName0[0].contains("IDAR")) {
//			if(!fileName0[0].contains("IDAR")) {
//			if(!fileName0[0].contains("file")) {
			
				String line = null;
				edge = null;
				vertex = null;
				benignvertex = new ArrayList<String>();
				benignedge = HashBasedTable.create();
				
				try
				{
					FileReader fileReader = new FileReader("Work//graph-" + fileName0[0] + ".dg");
	                
		            BufferedReader bufferedReader = new BufferedReader(fileReader);
		            line = bufferedReader.readLine();
		            benignNumbers.add(line.split(" ")[2]);
		            line = bufferedReader.readLine();
	            	while ((line = bufferedReader.readLine()) != null && (line.startsWith("v"))) {
	            		vertex = line.split(" ");
	            		benignvertex.add(vertex[2]);
					}
	            	
	            	if (line != null && (line.startsWith("e"))) {
	            		edge = line.split(" ");
	            		benignedge.put(benignvertex.get(Integer.parseInt(edge[1])), benignvertex.get(Integer.parseInt(edge[2])), Integer.parseInt(edge[3]));
					}
	            	while ((line = bufferedReader.readLine()) != null && (line.startsWith("e"))) {
	            		edge = line.split(" ");
	            		benignedge.put(benignvertex.get(Integer.parseInt(edge[1])), benignvertex.get(Integer.parseInt(edge[2])), Integer.parseInt(edge[3]));
					}
	
					bufferedReader.close();
		            fileReader.close();
		            benignvertices.add(benignvertex);
					benignedges.add(benignedge);
				}
				catch(FileNotFoundException ex) {
					System.out.println("Unable to open file '" + fileName0[0] + "'");               
		        }
		        catch(IOException ex) {
		        	System.out.println("Error reading file '" + fileName0[0] + "'");                
		        }
				
			}
		}////for

        /////////////////////////////////////////////////////////////////////////////////////
		
		
		
		
	    for(int k = 0;k<count1;k++) {
	    	Boolean malCheckFlag = false;
	    	malwarevertex = new ArrayList<String>();
	    	malwareedge = HashBasedTable.create();
	    	malwarevertex.addAll(malwarevertices.get(k));
	    	malwareedge.putAll(malwareedges.get(k));
///////////////////////////////////////////////////////////////////////////////////////////////
	    	
	    	
	    	
	    	
	    	
	    	for(int l = 0;l<benignvertices.size();l++) {
	    		benignvertex = new ArrayList<String>();
				benignedge = HashBasedTable.create();
				
				benignvertex.addAll(benignvertices.get(l));
				benignedge.putAll(benignedges.get(l));
				
		        boolean malFlag = true;
		        if(benignvertex.containsAll(malwarevertex)) {
		        	if(malwareedge.size()>0){
		            	for (int i = 0;i<malwarevertex.size();i++) {
		            		for (int u = 0;u<malwarevertex.size();u++){
		            			if(malwareedge.contains(malwarevertex.get(i), malwarevertex.get(u)))
		            			{
			            			if (benignedge.contains(malwarevertex.get(i), malwarevertex.get(u)) && 
			            					benignedge.get(malwarevertex.get(i), malwarevertex.get(u))==malwareedge.get(malwarevertex.get(i), malwarevertex.get(u))) {
			            				malFlag = true;
										
			            			}
			            			else
			            			{
			            				malFlag = false;
			            				break;
			            			}
		            			}
		            			
		            		}
		            		if(malFlag == false){
		            			break;
		            		}
		            	}
		        	}
		        	else
		            {
		            	malFlag = true;
		            }
		        			
		        }
		        else
    			{
    				malFlag = false;
    			}
		        
		        if(malFlag) 
		        {
		        	featuresCount[k]++;
		        }
		        
	    	}
	    	

	    	if (featuresCount[k]!=originalFeaturesCount[k]){
	    		System.out.println("SubGraphCount " + k + ": " + featuresCount[k] + " " + originalFeaturesCount[k]);
	    		malCheckFlag = true;
	    	}

	    	
	    	
	    	
	    	
	    	
	    	
	    	
	    	
	    	
	    	
	    	
///////////////////////////////////////////////////////////////////////////////////////////////	    
	    	
	    	
	    	if(malCheckFlag){
	    		System.out.println("SubGraphCheck: Checking..." );
		    	
		    	
		    	
		    	int temp0 = 0;
		    		
	        	featuresCount[k] = 0;
        		
            	malwarevertex = new ArrayList<String>();
    	    	malwareedge = HashBasedTable.create();
    	    	malwarevertex.addAll(malwarevertices.get(k));
    	    	malwareedge.putAll(malwareedges.get(k));
//    	    	benignNumbers.indexOf(Integer.parseInt(malwareXList.get(k).split(" ")[1]));

    	    	benignvertex = new ArrayList<String>();
				benignedge = HashBasedTable.create();
				
//				temp0 = benignNumbers.indexOf(Integer.parseInt(malwareXList.get(k).split(" ")[1]));
				System.out.println("benignNumbers: " +  benignNumbers);
				System.out.println("benignNumbers: " +  Integer.parseInt(malwareXList.get(k).split(" ")[1]));
//				System.out.println("benignvertices size: " +  benignvertices.size());
//				System.out.println("temp0: " +  temp0);
				benignvertex.addAll(benignvertices.get(Integer.parseInt(malwareXList.get(k).split(" ")[1])));
				benignedge.putAll(benignedges.get(Integer.parseInt(malwareXList.get(k).split(" ")[1])));
				
				for (int i = 0;i<malwarevertex.size();i++) {
            		for (int u = 0;u<malwarevertex.size();u++){
            			if(malwareedge.contains(malwarevertex.get(i), malwarevertex.get(u)))
            			{

	            			if (benignedge.contains(malwarevertex.get(i), malwarevertex.get(u)) && 
	            					benignedge.get(malwarevertex.get(i), malwarevertex.get(u))==malwareedge.get(malwarevertex.get(i), malwarevertex.get(u))) 
	            			{
				    	    	malwareedge.remove(malwarevertex.get(i), malwarevertex.get(u));
				            	
					            malwareedge.put(malwarevertex.get(i), malwarevertex.get(u), benignedge.get(malwarevertex.get(i), malwarevertex.get(u)));
	 
	            			}
	            			else if (benignedge.contains(malwarevertex.get(u), malwarevertex.get(i)) && 
	            					benignedge.get(malwarevertex.get(u), malwarevertex.get(i))==malwareedge.get(malwarevertex.get(i), malwarevertex.get(u)))
	            			{
	            				malwareedge.remove(malwarevertex.get(i), malwarevertex.get(u));
				            	
					            malwareedge.put(malwarevertex.get(u), malwarevertex.get(i), benignedge.get(malwarevertex.get(u), malwarevertex.get(i)));
	 
	            			}
            			}

            		}

            	}
						
				            
			    	for(int l = 0;l<benignvertices.size();l++) {
			    		benignvertex = new ArrayList<String>();
						benignedge = HashBasedTable.create();
						
						benignvertex.addAll(benignvertices.get(l));
						benignedge.putAll(benignedges.get(l));
						
				        boolean malFlag = true;
				        if(benignvertex.containsAll(malwarevertex)) {
//						        	System.out.println("first " + k + ": " + originalFeaturesCount[k]);
			        	if(malwareedge.size()>0){
//						        		System.out.println("second " + k + ": " + originalFeaturesCount[k]);
			            	for (int i = 0;i<malwarevertex.size();i++) {
			            		for (int u = 0;u<malwarevertex.size();u++){
//						            			System.out.println(l + " first " + k + ": " + malwarevertex.get(i) + " , " + malwarevertex.get(u) + " malwarevertex size: " + malwarevertex.size());
			            			if(malwareedge.contains(malwarevertex.get(i), malwarevertex.get(u)))
			            			{
//						            				System.out.println(l + " first-second " + k + ": " + malwarevertex.get(i) + " , " + malwarevertex.get(u));
//						            				malFlag = true;
				            			if (benignedge.contains(malwarevertex.get(i), malwarevertex.get(u)) && 
				            					benignedge.get(malwarevertex.get(i), malwarevertex.get(u))==malwareedge.get(malwarevertex.get(i), malwarevertex.get(u))) {
				            				malFlag = true;
//							            				System.out.println(l + " second " + k + ": " + malwarevertex.get(i) + " , " + malwarevertex.get(u) + " value: "
//							            						+ benignedge.get(malwarevertex.get(i), malwarevertex.get(u))+ " " +malwareedge.get(malwarevertex.get(i), malwarevertex.get(u)));
											
				            			}
				            			else
				            			{
				            				malFlag = false;
				            				break;
				            			}
			            			}
//						            			else
//						            			{
//						            				break;
//						            			}
			            			
			            		}
			            		if(malFlag == false){
			            			break;
			            		}
			            	}
			        	}
			        	else
			            {
			            	malFlag = true;
			            }
			        			
			        }
			        else
        			{
        				malFlag = false;
        			}
			        
			        if(malFlag) 
			        {
			        	featuresCount[k]++;
			        }
			        
		    	}
//					    	System.out.println("	SubGraphCount " + k + ": " + featuresCount[k] + " " + originalFeaturesCount[k]);
	    		
		    	if (featuresCount[k]==originalFeaturesCount[k]){
		    		System.out.println("SubGraphCount " + k + ": " + featuresCount[k] + " " + originalFeaturesCount[k]);
		    		malCheckFlag = false;
		    		
		    	}
			    
			    
			    if(!malCheckFlag){
			    	malwarevertices.get(k).clear();
			    	malwareedges.get(k).clear();
			    	malwarevertices.get(k).addAll(malwarevertex);
			    	malwareedges.get(k).putAll(malwareedge);
			    }
//			    System.out.println("malwarevertex(size): "+k+" "+ malwarevertex.size() );
//			    System.out.println("malwareedge(size): "+k+" "+ malwareedge.size() );
//			    System.out.println("malwarevertex(size2): "+k+" "+ malwarevertices.get(k).size() );
//			    System.out.println("malwareedge(size2): "+k+" "+malwareedges.get(k).size() );
			    System.out.println("SubGraphCheck: Done" );
	    	}//if malCheckFlag
	    }//for K

	    
        try {

            FileWriter fileWriter = new FileWriter("Work//graphs.fp");

            for(int k = 0;k<count1;k++) {
    	    	malwarevertex = new ArrayList<String>();
    	    	malwareedge = HashBasedTable.create();
    	    	malwarevertex.addAll(malwarevertices.get(k));
    	    	malwareedge.putAll(malwareedges.get(k));
    	    	System.out.println("t # " + k + " * " + featuresCount[k]);
    	    	fileWriter.write("t # " + k + " * " + featuresCount[k] + "\n");
    	    	for(int i = 0;i<malwarevertex.size();i++) {
    	    		System.out.println("v " + i + " " + malwarevertex.get(i));
    	    		fileWriter.write("v " + i + " " + malwarevertex.get(i) + "\n");
    	    	}
                for (int i = 0;i<malwarevertex.size();i++) {
            		for (int c = 0;c<malwarevertex.size();c++){
            			if(malwareedge.contains(malwarevertex.get(i), malwarevertex.get(c)) && malwareedge.get(malwarevertex.get(i), malwarevertex.get(c))>0)
            			{
            				System.out.println("e " + malwarevertex.indexOf(malwarevertex.get(i))  + " " + malwarevertex.indexOf(malwarevertex.get(c)) + " " + malwareedge.get(malwarevertex.get(i), malwarevertex.get(c)));
            				fileWriter.write("e " + malwarevertex.indexOf(malwarevertex.get(i))  + " " + malwarevertex.indexOf(malwarevertex.get(c)) + " " + malwareedge.get(malwarevertex.get(i), malwarevertex.get(c)) + "\n");
            			}
            			
            		}
            		
            	}
                System.out.println(malwareXList.get(k));
                fileWriter.write(malwareXList.get(k) + "\n\n");
                System.out.println();
    	    }
            
            fileWriter.flush();
            fileWriter.close();
            
           
        }
        catch(FileNotFoundException ex) {
        	System.out.println("Unable to open file '" + "graphs.fp" + "'");               
        }
        catch(IOException ex) {
        	System.out.println("Error reading file '" + "graphs.fp" + "'");                
        }
	    
	    
	    
	    
	}
	
	public void FileSelect() {
		File folder = new File("//home//amir//workspace//MalwareDetector//DataSet//");
		selectedFile = folder.listFiles(new FileFilter() {
		    @Override
		    public boolean accept(File file) {
		        return !file.isHidden();
		    }
		});
		Arrays.sort(selectedFile);
//				.listFiles();
		System.setProperty("user.dir","");
		String curDir = System.getProperty("user.dir");
		for (int i =0; i<selectedFile.length;i++)
			System.out.println("Selected file: " + selectedFile[i].getAbsolutePath() + "\n" + selectedFile[i].getName() + "\n" + curDir + i);
	}
	
	public void AutoFileSelect(String DataSet) {
		File folder = new File("//home//amir//workspace//MalwareDetector//" + DataSet + "//");
		selectedFile = folder.listFiles(new FileFilter() {
		    @Override
		    public boolean accept(File file) {
		        return !file.isHidden();
		    }
		});
		Arrays.sort(selectedFile);
//				.listFiles();
		System.setProperty("user.dir","");
		String curDir = System.getProperty("user.dir");
		for (int i =0; i<selectedFile.length;i++)
			System.out.println("Selected file: " + selectedFile[i].getAbsolutePath() + "\n" + selectedFile[i].getName() + "\n" + curDir + i);
	}

	public void AutoSubGraph(String DataSet) {
		String[] fileName = null;
		String line = null;
		String[] vertices = null;
		String vName = null;

		switch(DataSet){
			case "NGVCK" :
				vName = "IDAN";
				break; 
			case "MPCGEN" :
				vName = "mpcgen";
				break; 
			case "G2" :
				vName = "g2";
				break; 
			case "MWOR1.0" :
				vName = "MWOR1";
				break; 
			case "MWOR2.0" :
				vName = "MWOR2";
				break; 
			case "MWOR3.0" :
				vName = "MWOR3";
				break; 
			case "MWOR4.0" :
				vName = "MWOR4";
				break; 
			default : 
				vName = "IDAR";
		}

		try
		{
			
			FileWriter fileWriter = new FileWriter("Work//graphs");
			for(int k = 0;k<selectedFile.length;k++) {
				fileName = selectedFile[k].getName().split("\\.");
				if(fileName[0].toString().contains(vName)) {
					line = null;
					vertices = null;
					FileReader fileReader = new FileReader("Work//graph-" + fileName[0] + ".dg");
					BufferedReader bufferedReader = new BufferedReader(fileReader);
					if((line = bufferedReader.readLine()) != null && line.startsWith("t # " + k)) {
						fileWriter.write(line);
						fileWriter.write("\n");
						line = bufferedReader.readLine();
						vertices = line.split(" ");

						for(int i=0;i<vertices.length;i++) {			
							line = bufferedReader.readLine();
							fileWriter.write(line);
							fileWriter.write("\n");
						}
						
						while ((line = bufferedReader.readLine()) != null && line.startsWith("e ")) {
							fileWriter.write(line);
							fileWriter.write("\n");
						}
					}

					bufferedReader.close();
					fileReader.close();
				}
				
			}
			fileWriter.flush();
			fileWriter.close();

		}
		catch(FileNotFoundException ex) {
			System.out.println("Unable to open file '" + fileName + "'");               
		}
		catch(IOException ex) {
			System.out.println("Error reading file '" + fileName + "'");                
		}
		finally
		{
			System.out.println("SubGraphs: Done ");
		}
		double Frequency = 1.0;
		if(!txtFrequency.getText().isEmpty())
			Frequency = Double.parseDouble(txtFrequency.getText());
		else 
			Frequency = autoFrequency;
		
		long startTime   = System.nanoTime();
		try { 
			Process p = Runtime.getRuntime().exec("Work//gSpan -f Work//graphs -s " + Frequency + " -o -i");
			p.waitFor();
			System.out.println("SubGraphs: Done!!!! ");
		} catch (IOException | InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		long endTime   = System.nanoTime();
		long totalTime = endTime - startTime;
		try {
			FileWriter timesWriter = new FileWriter("Work//scantimes", true);
			timesWriter.write("subgraph :" + Long.toString(totalTime) + "\n");
			timesWriter.flush();
			timesWriter.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		
	}

	public void Pre() {
		
		table = HashBasedTable.create();
		list = new ArrayList<>();
		allLists = null;
		////////////////////////////////////////////////
		featuresList = new Hashtable<String, String>();
		selectedFile = null;
		////////////////////////////////////////////////

		fsgraph = null;
		fsparent = null;
		fsvertexlist = new ArrayList<>();
		fsvertexlists = new ArrayList<ArrayList<Object>>();
		////////////////////////////////////////////////
		graph = new mxGraph[241];
		parent = new Object[241];
		vertexlist = new ArrayList<>();
		vertexlists = new ArrayList<ArrayList<Object>>();


	}
	
	public void Post() {
		
	    
//		File source = new File("Work//bigramlist");
//		File dest = new File("bigramlist");
//	    try {
//	    	FileUtils.copyFile(source, dest);
////	    	Files.copy(FROM, TO, options);
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//		Path FROM = Paths.get("Work//bigramlist");
//	    Path TO = Paths.get("bigramlist");
//	    //overwrite existing file, if exists
//	    CopyOption[] options = new CopyOption[]{
//	      StandardCopyOption.REPLACE_EXISTING,
//	      StandardCopyOption.COPY_ATTRIBUTES
//	    }; 
//	    try {
//			Files.copy(FROM, TO, options);
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
//		File folder = new File("Work//");
//		File[] workFiles = folder.listFiles();
//		for (int i =0; i<workFiles.length;i++) {
//			try{
//	    		if(!workFiles[i].getName().equals("gSpan") && !workFiles[i].getName().equals("bigramlist") && workFiles[i].delete()){
//	    			System.out.println(workFiles[i].getName() + " is deleted!");
//	    		}else{
//	    			System.out.println("Delete" + workFiles[i].getName() + " is failed.");
//	    		}
//	    	   
//	    	}catch(Exception e){
//	    		
//	    		e.printStackTrace();
//	    		
//	    	}
//		}
		
		File source = new File("Work//time");
		try{
    		if(source.delete()){
    			System.out.println(source.getName() + " is deleted!");
    		}else{
    			System.out.println("Delete" + source.getName() + " is failed.");
    		}
    	   
    	}catch(Exception e){
    		
    		e.printStackTrace();
    		
    	}
		source = new File("Work//scantimes");
		try{
    		if(source.delete()){
    			System.out.println(source.getName() + " is deleted!");
    		}else{
    			System.out.println("Delete" + source.getName() + " is failed.");
    		}
    	   
    	}catch(Exception e){
    		
    		e.printStackTrace();
    		
    	}
		source = new File("Work//weka-malware.arff");
		try{
    		if(source.delete()){
    			System.out.println(source.getName() + " is deleted!");
    		}else{
    			System.out.println("Delete" + source.getName() + " is failed.");
    		}
    	   
    	}catch(Exception e){
    		
    		e.printStackTrace();
    		
    	}
//		source = new File("gSpan");
//		dest = new File("Work//gSpan");
//	    try {
//	    	FileUtils.copyFile(source, dest);
////	    	Files.copy(FROM, TO, options);
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//	    source = new File("bigramlist");
//		dest = new File("Work//bigramlist");
//	    try {
//	    	FileUtils.copyFile(source, dest);
////	    	Files.copy(FROM, TO, options);
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//		Path FROM = Paths.get("gSpan");
//		Path TO = Paths.get("Work//gSpan");
//	    
//	    try {
//			Files.copy(FROM, TO, options);
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//	    FROM = Paths.get("bigramlist");
//	    TO = Paths.get("Work//bigramlist");
//
//	    try {
//			Files.copy(FROM, TO, options);
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
	}
	
	
	public void SubGraph() {
		String[] fileName = null;
		String line = null;
		String[] vertices = null;
		
		try
		{
			
			FileWriter fileWriter = new FileWriter("Work//graphs");
			for(int k = 0;k<selectedFile.length;k++) {
				fileName = selectedFile[k].getName().split("\\.");
				if(!fileName[0].toString().contains("IDAR")) {
//				if(!fileName[0].toString().contains("IDAR")) {
//				if(!fileName[0].toString().contains("file")) {
					line = null;
					vertices = null;
					FileReader fileReader = new FileReader("Work//graph-" + fileName[0] + ".dg");
					BufferedReader bufferedReader = new BufferedReader(fileReader);
					if((line = bufferedReader.readLine()) != null && line.startsWith("t # " + k)) {
						fileWriter.write(line);
						fileWriter.write("\n");
						line = bufferedReader.readLine();
						vertices = line.split(" ");

						for(int i=0;i<vertices.length;i++) {			
							line = bufferedReader.readLine();
							fileWriter.write(line);
							fileWriter.write("\n");
						}
						
						while ((line = bufferedReader.readLine()) != null && line.startsWith("e ")) {
							fileWriter.write(line);
							fileWriter.write("\n");
						}
					}

					bufferedReader.close();
					fileReader.close();
				}
				
			}
			fileWriter.flush();
			fileWriter.close();

		}
		catch(FileNotFoundException ex) {
			System.out.println("Unable to open file '" + fileName + "'");               
		}
		catch(IOException ex) {
			System.out.println("Error reading file '" + fileName + "'");                
		}
		finally
		{
			System.out.println("SubGraphs: Done ");
		}
		double Frequency = 1.0;
		if(!txtFrequency.getText().isEmpty())
			Frequency = Double.parseDouble(txtFrequency.getText());
		else 
			Frequency = autoFrequency;
		
//		gSpan subgraph = new gSpan(Frequency);
//		
//		Thread subgraphthread = new Thread(subgraph);
		long startTime   = System.nanoTime();
		try { 
			Process p = Runtime.getRuntime().exec("Work//gSpan -f Work//graphs -s " + Frequency + " -o -i");
			p.waitFor();
			System.out.println("SubGraphs: Done!!!! ");
		} catch (IOException | InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
//		subgraphthread.start();
//				try {
//					double Frequency = Double.parseDouble(txtFrequency.getText()); 
//					Process p = Runtime.getRuntime().exec("Work//gSpan -f Work//graphs -s " + Frequency + " -o -i");
//				} catch (IOException e) {
//					// TODO Auto-generated catch block
//					e.printStackTrace();
//				}
//		try {
//			subgraphthread.join();
//			System.out.println("SubGraphs: Done!!!! ");
//		} catch (InterruptedException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		long endTime   = System.nanoTime();
		long totalTime = endTime - startTime;
		try {
			FileWriter timesWriter = new FileWriter("Work//scantimes", true);
			timesWriter.write("subgraph :" + Long.toString(totalTime) + "\n");
			timesWriter.flush();
			timesWriter.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		SubGraphCheck4();
	}

	public void CreateGraph() {
		OpCodeExtraction();
		CreateBigram();
		
		String[] verticeslist = null;
		ArrayList<String> allvertices = new ArrayList<>();
		String line = null;
		Set<String> vertexSet = new HashSet<String>();
		
		try
		{
			
			FileReader fileReader = new FileReader("Work//bigramlist");
			
			BufferedReader bufferedReader = new BufferedReader(fileReader);
			if((line = bufferedReader.readLine()) != null) {
				verticeslist = line.split(" ");
			}
			
			bufferedReader.close();
			fileReader.close();

		}
		catch(FileNotFoundException ex) {
			System.out.println("Unable to open file '" + "Work//bigramlist" + "'");               
		}
		catch(IOException ex) {
			System.out.println("Error reading file '" + "Work//bigramlist" + "'");                
		}
		if(verticeslist!=null)
			for(int i=0;i<verticeslist.length;i++) {
				if(vertexSet.add(verticeslist[i]))
					allvertices.add(verticeslist[i]);
			}
		

		
//		vertexSet = new HashSet<String>();

		for(int k = 0;k<selectedFile.length;k++) {
			String[] fileName = selectedFile[k].getName().split("\\.");
			line = null;
			String[] vertices = null;
			String[] edges = null;
			
			try
			{
				FileReader fileReader = new FileReader("Work//bigram-" + fileName[0] + ".bg");
				FileWriter fileWriter = new FileWriter("Work//graph-" + fileName[0] + ".dg");

				fileWriter.write("t # " + k);
				fileWriter.write("\n");
				
				BufferedReader bufferedReader = new BufferedReader(fileReader);
				if((line = bufferedReader.readLine()) != null) {
					fileWriter.write(line);
					fileWriter.write("\n");
					vertices = line.split(" ");
				}
				
				for(int i=0;i<vertices.length;i++) {
					if(vertexSet.add(vertices[i]))
						allvertices.add(vertices[i]);
				}
				
				
				for(int i=0;i<vertices.length;i++) {
					fileWriter.write("v " + i + " " + allvertices.indexOf(vertices[i]) + "\n");
				}
				
				for(int i=0;i<vertices.length;i++) {
					
					if((line = bufferedReader.readLine()) != null) {
						edges = line.split(" ");
						for(int j=0;j<edges.length;j++) {
							if(Double.parseDouble(edges[j]) > 0.0)
								fileWriter.write("e " + i + " " + j + " " + (int)(Double.parseDouble(edges[j]) * 100) + "\n");
							
						}
						
					}
				}
				
				bufferedReader.close();
				fileReader.close();
				fileWriter.flush();
				fileWriter.close();
			}
			catch(FileNotFoundException ex) {
				System.out.println("Unable to open file '" + fileName + "'");               
			}
			catch(IOException ex) {
				System.out.println("Error reading file '" + fileName + "'");                
			}
			finally
			{
				System.out.println("Create Graph: Done ");

				
			}
		}
		
		 //////////////////////////////////
		 //////////////////////////////////
		 /////////////////////////////
		 /////////////////////////////
		

		
		try
		{
			FileWriter fileWriter = new FileWriter("Work//bigramlist");

			for(int i=0;i<allvertices.size();i++) {
				if(i!=allvertices.size()-1)
					fileWriter.write(allvertices.get(i) + " ");
				else
					fileWriter.write(allvertices.get(i));
			}
			

			fileWriter.flush();
			fileWriter.close();
		}
		catch(FileNotFoundException ex) {
			System.out.println("Unable to open file '" + "Work//bigramlist" + "'");               
		}
		catch(IOException ex) {
			System.out.println("Error reading file '" + "Work//bigramlist" + "'");                
		}
		
		LoadGraphs();
	}

	public void ScanFiles() {
				
				String fileName1 = "Work//graphs.fp";
				String line1 = null;
				int count1 = 0;
				int maxcount = 200;
				if(maxcount < selectedFile.length)
					maxcount = selectedFile.length;
				try
				{
					FileReader fileReader = new FileReader(fileName1);
	                
		            BufferedReader bufferedReader = new BufferedReader(fileReader);

	            	while ((line1 = bufferedReader.readLine()) != null) {
	            		if(line1.startsWith("t #")) {
	            			count1++;
	            		}
	            			
					}
	            	
					bufferedReader.close();
		            fileReader.close();

				}
				catch(FileNotFoundException ex) {
					System.out.println("Unable to open file '" + fileName1 + "'");               
		        }
		        catch(IOException ex) {
		        	System.out.println("Error reading file '" + fileName1 + "'");                
		        }
				
				Hashtable<String, Integer> features = new Hashtable<String, Integer>();
				int[][] featuresCount = new int[count1][maxcount];
	            int currentGraph=0;
	            for (int i=0;i<count1;i++)
	            	for (int j=0;j<maxcount;j++)
	            		featuresCount[i][j]=0;
	            
				for(int l = 0;l<selectedFile.length;l++) {
					
					ArrayList<String> graphSet = new ArrayList<>();
					
					String[] fileName0 = selectedFile[l].getName().split("\\.");
					String line = null;
					String[] edge = null;
					String[] vertex = null;
					int count = 0;
					ArrayList<String> benignvertices = new ArrayList<>();
					Table<String, String, Integer> benignedges = HashBasedTable.create();
					
					ArrayList<String> malwarevertices = new ArrayList<>();
					Table<String, String, Integer> malwareedges = HashBasedTable.create();
					
					try
					{
						FileReader fileReader = new FileReader("Work//graph-" + fileName0[0] + ".dg");
		                
			            BufferedReader bufferedReader = new BufferedReader(fileReader);
			            line = bufferedReader.readLine();
			            currentGraph = Integer.parseInt(line.split(" ")[2]);
			            System.out.println(currentGraph + " match: ");
			            line = bufferedReader.readLine();
		            	while ((line = bufferedReader.readLine()) != null && (line.startsWith("v"))) {
		            		vertex = line.split(" ");
		            		benignvertices.add(vertex[2]);
						}
		            	
		            	if (line != null && (line.startsWith("e"))) {
		            		edge = line.split(" ");
		            		benignedges.put(benignvertices.get(Integer.parseInt(edge[1])), benignvertices.get(Integer.parseInt(edge[2])), Integer.parseInt(edge[3]));
						}
		            	while ((line = bufferedReader.readLine()) != null && (line.startsWith("e"))) {
		            		edge = line.split(" ");
		            		benignedges.put(benignvertices.get(Integer.parseInt(edge[1])), benignvertices.get(Integer.parseInt(edge[2])), Integer.parseInt(edge[3]));
						}
	
						bufferedReader.close();
			            fileReader.close();
	
					}
					catch(FileNotFoundException ex) {
						System.out.println("Unable to open file '" + fileName0[0] + "'");               
			        }
			        catch(IOException ex) {
			        	System.out.println("Error reading file '" + fileName0[0] + "'");                
			        }
					
					String fileName = "Work//graphs.fp";
					
					try
					{
						FileReader fileReader = new FileReader(fileName);
		                
			            BufferedReader bufferedReader = new BufferedReader(fileReader);
	
		            	while ((line = bufferedReader.readLine()) != null) {
		            		if(line.startsWith("t #"))
		            			count++;
						}
	
						bufferedReader.close();
			            fileReader.close();
	
					}
					catch(FileNotFoundException ex) {
						System.out.println("Unable to open file '" + fileName + "'");               
			        }
			        catch(IOException ex) {
			        	System.out.println("Error reading file '" + fileName + "'");                
			        }
	
					
					try
					{
						FileWriter fileWriter = new FileWriter("Work//malware-graphs-" + fileName0[0] +".mg");
						FileReader fileReader = new FileReader(fileName);
		                
			            BufferedReader bufferedReader = new BufferedReader(fileReader);
			            long startTime = System.nanoTime();
			            for(int k = 0;k<count;k++) {
			            	malwarevertices = new ArrayList<>();
			            	
							malwareedges = HashBasedTable.create();
				            if((line = bufferedReader.readLine()) != null && line.startsWith("t # " + k)) {
				            	
				            	
				            	while ((line = bufferedReader.readLine()) != null && line.startsWith("v ")) {		
				            		vertex = line.split(" ");
				            		malwarevertices.add(vertex[2]);
				            	}
				            	
				            	while ((line != null) && line.startsWith("e ")) {
				            		edge = line.split(" ");
				            		malwareedges.put(malwarevertices.get(Integer.parseInt(edge[1])), malwarevertices.get(Integer.parseInt(edge[2])), Integer.parseInt(edge[3]));
				            		
				            		line = bufferedReader.readLine();
				            	}
				            	
					            if(line != null && line.startsWith("x ")) {
									line = bufferedReader.readLine();
					            }
				            	
				            	
				            }

///////////////////////////////////////////////////////////////////////////////////
				            
				            boolean malFlag = true;
				            if(benignvertices.containsAll(malwarevertices)) {
				            	
				            	if(malwareedges.size()>0){
				            		
					            	for (int i = 0;i<malwarevertices.size();i++) {
					            		for (int j = 0;j<malwarevertices.size();j++){
					            			if(malwareedges.contains(malwarevertices.get(i), malwarevertices.get(j)))
					            			{
					            				System.out.println(k + " " + "compare: " + benignedges.get(malwarevertices.get(i), malwarevertices.get(j))+ " " + malwareedges.get(malwarevertices.get(i), malwarevertices.get(j)));
						            			if (benignedges.contains(malwarevertices.get(i), malwarevertices.get(j)) && 
						            					benignedges.get(malwarevertices.get(i), malwarevertices.get(j))==malwareedges.get(malwarevertices.get(i), malwarevertices.get(j))) {
						            				malFlag = true;
													
						            			}
						            			else
						            			{
						            				malFlag = false;
						            				break;
						            			}
					            			}
					            			
					            		}
					            		if(malFlag == false)
					            			break;
					            	}
				            	}
				            	else
					            {
					            	malFlag = true;
					            }
				            			
				            }
				            else
			    			{
			    				malFlag = false;
			    			}
				            
				            if(malFlag) 
				            {
				            	System.out.println(k + " " + malFlag);
	            				graphSet.add(Integer.toString(1));
	            				
	            				featuresCount[k][currentGraph]++;
				            }
				            else
	            			{
//	            				System.out.println(k + " " +0 + " " + malFlag);
	            				graphSet.add(Integer.toString(0));
	            			}
				            
				            
				            
			            }//for
			            long endTime   = System.nanoTime();
			    		long totalTime = endTime - startTime;
			    		try {
			    			FileWriter timesWriter = new FileWriter("Work//scantimes", true);
			    			timesWriter.write("scan " + fileName0[0] + ": " + Long.toString(totalTime) + "\n");
			    			timesWriter.flush();
			    			timesWriter.close();
			    		} catch (IOException e) {
			    			// TODO Auto-generated catch block
			    			e.printStackTrace();
			    		}

////////////////////////////////////////////////////////////////////////////////////////////////
			            
			            
					        
			            
			            
////////////////////////////////////////////////////////////////////////////////////////////////			            
			            
			            
			            
			            for (int i = 0;i<graphSet.size();i++) {
			            	fileWriter.write((String)graphSet.get(i));
			            	if(features.containsKey((String)graphSet.get(i)))
			            		features.put((String)graphSet.get(i), features.get((String)graphSet.get(i))+1);
			            	else
			            		features.put((String)graphSet.get(i), 1);
			            	
			            	if(i<graphSet.size()-1)
			            		fileWriter.write(" ");
			            }
			            fileWriter.flush();
			            fileWriter.close();
						bufferedReader.close();
			            fileReader.close();
	
					}
					catch(FileNotFoundException ex) {
						System.out.println("Unable to open file '" + fileName + "'");               
			        }
			        catch(IOException ex) {
			        	System.out.println("Error reading file '" + fileName + "'");                
			        }
					finally
					{
						
						System.out.println("Matching: Done ");
	
			            
					}
					
					
					
					
				}
//				SubGraphCheck2();
//				SubGraphCheck3();
				Set<String> keys = features.keySet();
				Collection<Integer> values = features.values();
				System.out.println();
				System.out.println();
				try
				{
					FileWriter fileWriter = new FileWriter("Work//malware-graphs.mg");
					
					Iterator<String> keyiter = keys.iterator();
					Iterator<Integer> valueiter = values.iterator();
					while (keyiter.hasNext() && valueiter.hasNext()) {
					    fileWriter.write(keyiter.next() + " " + valueiter.next() + " \n");
					    
					}

		            
				fileWriter.flush();
	            fileWriter.close();
				}
				catch(FileNotFoundException ex) {
					System.out.println("Unable to open file '" + "Work//malware-graphs.mg" + "'");               
		        }
		        catch(IOException ex) {
		        	System.out.println("Error reading file '" + "Work//malware-graphs.mg" + "'");                
		        }
			
				int sum = 0;
				for(int i = 0;i<count1;i++) {
					sum = 0;
					for(int j = 0;j<maxcount;j++)
						sum += featuresCount[i][j];
					System.out.println("t # " + i + " * " + sum);
					
					for(int j = 0;j<maxcount;j++)
						if (featuresCount[i][j]>0)
							System.out.print(j + " ");
					
					System.out.println("\n");
				}
				System.out.println("Scan File: Done");               

				ScanLoad();
				
			}
	
	public void ExportArff() {
		
		String line = null;
		
		try
		{
			
            FileWriter fileWriter = new FileWriter("Work//weka-piracy.arff");
            fileWriter.write("@relation malware" + "\n\n");
            
            String[] fileName0 = selectedFile[0].getName().split("\\.");

			line = null;
			FileReader fileReader0 = new FileReader("Work//malware-graphs-" + fileName0[0] + ".mg");
			
            BufferedReader bufferedReader0 = new BufferedReader(fileReader0);
            if((line = bufferedReader0.readLine()) != null) {
            	String[] features = line.split(" ");
            	for(int i = 0;i<features.length;i++)  {
            		fileWriter.write("@attribute graph"+i+" {0, 1}\n");
            	}
            }
            
            bufferedReader0.close();
	        fileReader0.close();
            

            fileWriter.write("@attribute status {morphed, benign}" + "\n\n");
            fileWriter.write("@data" + "\n");
            
            for(int k = 0;k<selectedFile.length;k++) {
				String[] fileName = selectedFile[k].getName().split("\\.");

				line = null;
				FileReader fileReader = new FileReader("Work//malware-graphs-" + fileName[0] + ".mg");
				
	            BufferedReader bufferedReader = new BufferedReader(fileReader);
	            if((line = bufferedReader.readLine()) != null) {
	            	String[] features = line.split(" ");
	            	for(int i = 0;i<features.length;i++)  {
	            		fileWriter.write(features[i] + ",");
	            	}
	            	
	            	if(fileName[0].contains("IDAR"))
//	            	if(!fileName[0].contains("file"))
	            		fileWriter.write("benign" + "\n");
//	            	if(fileName[0].contains("file"))
//	            		fileWriter.write("morphed" + "\n");
	            	if(fileName[0].contains("IDAN"))
	            		fileWriter.write("malware" + "\n");
//	            		fileWriter.write("NGVCK" + "\n");
	            	if(fileName[0].contains("mpcgen"))
	            		fileWriter.write("MPCGEN" + "\n");
	            	if(fileName[0].contains("g2"))
	            		fileWriter.write("G2" + "\n");
	            	if(fileName[0].contains("MWOR1"))
	            		fileWriter.write("MWOR1.0" + "\n");
	            	if(fileName[0].contains("MWOR2"))
	            		fileWriter.write("MWOR2.0" + "\n");
	            	if(fileName[0].contains("MWOR3"))
	            		fileWriter.write("MWOR3.0" + "\n");
	            	if(fileName[0].contains("MWOR4"))
	            		fileWriter.write("MWOR4.0" + "\n");
	            }
	            
	            bufferedReader.close();
		        fileReader.close();

				    
				    
            }
			fileWriter.flush();
            fileWriter.close();
		            
				

		}
		catch(FileNotFoundException ex) {
			System.out.println("Unable to open file '" + "weka" + "'");               
        }
        catch(IOException ex) {
        	System.out.println("Error reading file '" + "weka" + "'");                
        }
		finally
		{
			System.out.println("Export Arff File: Done"); 
		}
	}
	
	public void ScanLoad() {
		String line = null;
		for(int k = 0;k<selectedFile.length;k++) {
			String[] fileName = selectedFile[k].getName().split("\\.");

			line = null;

			try
			{
				FileReader fileReader = new FileReader("Work//malware-graphs-" + fileName[0] + ".mg");
				
	            BufferedReader bufferedReader = new BufferedReader(fileReader);
	            if((line = bufferedReader.readLine()) != null) {
	            	featuresList.put(fileName[0], line);
	            }

				bufferedReader.close();
	            fileReader.close();

			}
			catch(FileNotFoundException ex) {
				System.out.println("Unable to open file '" + fileName + "'");               
	        }
	        catch(IOException ex) {
	        	System.out.println("Error reading file '" + fileName + "'");                
	        }
			finally
			{
				comboBox.addItem(fileName[0]);
	            comboBox_1.addItem(fileName[0]);
			}
		}
	}

	
	public void LoadSubGraphs() {
		String fileName = "Work//graphs.fp";
		String line = null;
		String line0 = null;
		String[] vertices = null;
		String[] edge = null;
		String[] vertex = null;
		int count = 0;
		try
		{
			FileReader fileReader = new FileReader(fileName);
            
            BufferedReader bufferedReader = new BufferedReader(fileReader);

        	while ((line = bufferedReader.readLine()) != null) {
        		if(line.startsWith("t #"))
        			count++;
			}

			bufferedReader.close();
            fileReader.close();

		}
		catch(FileNotFoundException ex) {
			System.out.println("Unable to open file '" + fileName + "'");               
        }
        catch(IOException ex) {
        	System.out.println("Error reading file '" + fileName + "'");                
        }
		
		fsvertexlists = new ArrayList<ArrayList<Object>>();
		fscomboList.removeAllItems();
		fsgraph = new mxGraph[count];
		fsparent = new Object[count];
		

		System.out.println("count: "+count);
		
		try
		{
			
			
			
			FileReader fileReader0 = new FileReader("Work//bigramlist");
            
            BufferedReader bufferedReader0 = new BufferedReader(fileReader0);
            

            line0 = bufferedReader0.readLine();
            vertices = line0.split(" ");
			
			
			
            bufferedReader0.close();
            fileReader0.close();
			
			
			FileReader fileReader = new FileReader(fileName);
            
            BufferedReader bufferedReader = new BufferedReader(fileReader);
            for(int k = 0;k<count;k++) {
            	
            	
            	
            	
            	fsgraph[k] = new mxGraph();
				fsparent[k] = fsgraph[k].getDefaultParent();
				fsvertexlist = new ArrayList<>();
				
				fsgraph[k].getModel().beginUpdate();
				
				
				
	            if((line = bufferedReader.readLine()) != null && line.startsWith("t # " + k)) {
	            	

	            	int i = 0;
	            	while ((line = bufferedReader.readLine()) != null && line.startsWith("v ")) {		

	            		vertex = line.split(" ");

	            		fsvertexlist.add(fsgraph[k].insertVertex(fsparent[k], null, vertices[Integer.parseInt(vertex[2])], 10 + (i%10)*70, 10 + (i/10)*40, 60, 30));
	            		fsvertexlists.add(k,fsvertexlist);
	            		i++;
	            		
	            	}
	            	
	            	while ((line != null) && line.startsWith("e ")) {
	            		edge = line.split(" ");
	            		
	            		fsgraph[k].insertEdge(fsparent[k], null, Integer.parseInt(edge[3])/100.0, fsvertexlists.get(k).get(Integer.parseInt(edge[1])), fsvertexlists.get(k).get(Integer.parseInt(edge[2])));
	            		line = bufferedReader.readLine();
	            	}
	            	
		            if((line = bufferedReader.readLine()) != null && line.startsWith("x ")) {
		            	System.out.println(line);
						System.out.println("\n");
		            }
	            	
	            	
	            	
	            }

	            fsgraph[k].getModel().endUpdate();
				
				fscomboList.addItem("Graph " + k);
            }//for
            
            
			bufferedReader.close();
            fileReader.close();

		}
		catch(FileNotFoundException ex) {
			System.out.println("Unable to open file '" + fileName + "'");               
        }
        catch(IOException ex) {
        	System.out.println("Error reading file '" + fileName + "'");                
        }
		finally
		{
			
			System.out.println("Load SubGraphs: Done ");

            
		}
		
	}
	
	public void LoadGraphs() {
		String[] verticeslist = null;
		String line = null;
		try
		{
			FileReader fileReader = new FileReader("Work//bigramlist");
            
            BufferedReader bufferedReader = new BufferedReader(fileReader);
            line = bufferedReader.readLine();
            verticeslist = line.split(" ");
            
            bufferedReader.close();
            fileReader.close();

		}
		catch(FileNotFoundException ex) {
			System.out.println("Unable to open file '" + "Work//bigramlist" + "'");               
        }
        catch(IOException ex) {
        	System.out.println("Error reading file '" + "Work//bigramlist" + "'");                
        }
		
		graphComboList.removeAllItems();
		vertexlists = new ArrayList<ArrayList<Object>>();
		for(int k = 0;k<selectedFile.length;k++) {
			String[] fileName = selectedFile[k].getName().split("\\.");
			graph[k] = new mxGraph();
			parent[k] = graph[k].getDefaultParent();
			vertexlist = new ArrayList<>();
			
			
			line = null;
			String[] vertices = null;
			String[] edge = null;
			String[] vertex = null;

			graph[k].getModel().beginUpdate();
			
			try
			{
				FileReader fileReader = new FileReader("Work//graph-" + fileName[0] + ".dg");
                
	            BufferedReader bufferedReader = new BufferedReader(fileReader);
	            if((line = bufferedReader.readLine()) != null && line.startsWith("t # " + k)) {
	            	line = bufferedReader.readLine();
	            	vertices = line.split(" ");

	            	for(int i=0;i<vertices.length;i++) {			
	            		line = bufferedReader.readLine();
	            		vertex = line.split(" ");
	            		
	            		vertexlist.add(graph[k].insertVertex(parent[k], null, verticeslist[Integer.parseInt(vertex[2])], 10 + (i%10)*70, 10 + (i/10)*40, 60, 30));
	            		vertexlists.add(k,vertexlist);
	            		
	            	}
	            	
	            	while ((line = bufferedReader.readLine()) != null && line.startsWith("e ")) {
	            		edge = line.split(" ");
	            		
	            		graph[k].insertEdge(parent[k], null, Integer.parseInt(edge[3])/100.0, vertexlists.get(k).get(Integer.parseInt(edge[1])), vertexlists.get(k).get(Integer.parseInt(edge[2])));
	            		
					}
	            	
	            }

				bufferedReader.close();
	            fileReader.close();

			}
			catch(FileNotFoundException ex) {
				System.out.println("Unable to open file '" + fileName + "'");               
	        }
	        catch(IOException ex) {
	        	System.out.println("Error reading file '" + fileName + "'");                
	        }
			finally
			{
				graph[k].getModel().endUpdate();
				graphComboList.addItem("Graph " + k);
				System.out.println("Load Graphs: Done ");

	            
			}
		}
	}

	public void OpCodeExtraction() {
		for (int i=0;i<selectedFile.length;i++){
			String[] fileName = selectedFile[i].getName().split("\\.");
			String firstPattern = null;
			if(simplePattern.isSelected())
			//(^(\t\t)((mov
		        firstPattern = "(((mov|cmove|cmovz|cmovne|cmovnz|cmova|cmovnbe|cmovae|cmovnb|cmovb|cmovnae|cmovbe|cmovna|cmovg|cmovnle|cmovge|cmovnl|cmovl|cmovnge|cmovle|cmovng|cmovc|cmovnc|cmovo|cmovno" +
		            "|cmovs|cmovns|cmovp|cmovpe|cmovnp|cmovpo|xchg|bswap|xadd|cmpxchg|cmpxchg8b|push|pop|pusha|pushad|popa|popad|cwd|cdq|cbw|cwde|movsx|movzx|adcx|adox|add|adc|sub|sbb|imul|mul|idiv" +
		            "|div|inc|dec|neg|cmp|daa|das|aaa|aas|aam|aad|and|or|xor|not|sar|shr|sal|shl|shrd|shld|ror|rol|rcr|rcl|bt|bts|btr|btc|bsf|bsr|sete|setz|setne|setnz|seta|setnbe|setae|setnb|setnc" +
		            "|setb|setnae|setcset|setbe|setna|setg|setnle|setge|setnl|setl|setnge|setle|setng|sets|setns|seto|setno|setpe|setp|setpo|setnp|test|crc32|popcnt|jmp|je|jz|jne|jnz" +
		            "|ja|jnbe|jae|jnb|jb|jnae|jbe|jna|jg|jnle|jge|jnl|jl|jnge|jle|jng|jc|jnc|jo|jno|js|jns|jpo|jnp|jpe|jp|jcxz|jecxz|loop|loopz|loope|loopnz|loopne|call|ret|iret|int|into|bound" +
		            "|enter|leave|movs|movsb|movs|movsw|movs|movsd|cmps|cmpsb|cmps|cmpsw|cmps|cmpsd|scas|scasb|scas|scasw|scas|scasd|lods|lodsb|lods|lodsw|lods|lodsd|stos|stosb|stos|stosw" +
		            "|stos|stosd|rep|repe|repz|repne|repnz|in|out|ins|insb|ins|insw|ins|insd|outs|outsb|outs|outsw|outs|outsd|enter|leave|stc|clc|cmc|cld|std|lahf|sahf|pushf|pushfd|popf|popfd" +
		            "|sti|cli|lds|les|lfs|lgs|lss|lea|nop|ud2|xlat|xlatb|cpuid|movbe|prefetchw|prefetchwt|rdrand|rdseed|andn|bextr|blsi|blsmsk|blsr|bzhi|lzcnt|mulx|pdep|pext|rorx|sarx|shlx|shrx|tzcnt)[a-z]*))";
//				firstPattern = "(((sub|call|add|ret|push|jmp|mov|test|je|lea|xor|jne|shl|cmove|and|jl|sbb|pop|cmovne|cmova|sete|adc|leave|dec|aaa|aad)[a-z]*))";
			else
//				firstPattern = "(((call|pop|sub|mov|jz|lea|neg|dec|add|cmp|jnz|inc|retn|jmp|shl|jb|ja|adc|rep|clc|test|cld|rcl|sbb|ror|leave|jg|jl|jge)[a-z]*))";
				firstPattern = "(^(\t\t)((mov|cmove|cmovz|cmovne|cmovnz|cmova|cmovnbe|cmovae|cmovnb|cmovb|cmovnae|cmovbe|cmovna|cmovg|cmovnle|cmovge|cmovnl|cmovl|cmovnge|cmovle|cmovng|cmovc|cmovnc|cmovo|cmovno" +
			            "|cmovs|cmovns|cmovp|cmovpe|cmovnp|cmovpo|xchg|bswap|xadd|cmpxchg|cmpxchg8b|push|pop|pusha|pushad|popa|popad|cwd|cdq|cbw|cwde|movsx|movzx|adcx|adox|add|adc|sub|sbb|imul|mul|idiv" +
			            "|div|inc|dec|neg|cmp|daa|das|aaa|aas|aam|aad|and|or|xor|not|sar|shr|sal|shl|shrd|shld|ror|rol|rcr|rcl|bt|bts|btr|btc|bsf|bsr|sete|setz|setne|setnz|seta|setnbe|setae|setnb|setnc" +
			            "|setb|setnae|setcset|setbe|setna|setg|setnle|setge|setnl|setl|setnge|setle|setng|sets|setns|seto|setno|setpe|setp|setpo|setnp|test|crc32|popcnt|jmp|je|jz|jne|jnz" +
			            "|ja|jnbe|jae|jnb|jb|jnae|jbe|jna|jg|jnle|jge|jnl|jl|jnge|jle|jng|jc|jnc|jo|jno|js|jns|jpo|jnp|jpe|jp|jcxz|jecxz|loop|loopz|loope|loopnz|loopne|call|ret|iret|int|into|bound" +
			            "|enter|leave|movs|movsb|movs|movsw|movs|movsd|cmps|cmpsb|cmps|cmpsw|cmps|cmpsd|scas|scasb|scas|scasw|scas|scasd|lods|lodsb|lods|lodsw|lods|lodsd|stos|stosb|stos|stosw" +
			            "|stos|stosd|rep|repe|repz|repne|repnz|in|out|ins|insb|ins|insw|ins|insd|outs|outsb|outs|outsw|outs|outsd|enter|leave|stc|clc|cmc|cld|std|lahf|sahf|pushf|pushfd|popf|popfd" +
			            "|sti|cli|lds|les|lfs|lgs|lss|lea|nop|ud2|xlat|xlatb|cpuid|movbe|prefetchw|prefetchwt|rdrand|rdseed|andn|bextr|blsi|blsmsk|blsr|bzhi|lzcnt|mulx|pdep|pext|rorx|sarx|shlx|shrx|tzcnt)[a-z]*))";
	        
			Pattern r = Pattern.compile(firstPattern);
	        String line = null;
	        Matcher m;
	        int count = 0;
	        
	        try {
	            FileReader fileReader = new FileReader(selectedFile[i]);
	            
	            FileWriter fileWriter = new FileWriter("Work//opcode-" + fileName[0] + ".asm");

	            BufferedReader bufferedReader = new BufferedReader(fileReader);

	            while((line = bufferedReader.readLine()) != null) {
	                m = r.matcher(line);
	                if (m.find( )) {

	                   fileWriter.write(m.group(3)); 
	                   fileWriter.write("\n");
	      
	                   count++;
	                }
	            }
	            
	            System.out.println("OpCode: Done " + count);

	            fileWriter.flush();
	            fileWriter.close();
	            bufferedReader.close();  
	            fileReader.close();
	            
	           
	        }
	        catch(FileNotFoundException ex) {
	        	System.out.println("Unable to open file '" + fileName + "'");               
	        }
	        catch(IOException ex) {
	        	System.out.println("Error reading file '" + fileName + "'");                
	        }
		}
	}
	
	public void CreateBigram() {
		for(int k = 0;k<selectedFile.length;k++) {
			String[] fileName = selectedFile[k].getName().split("\\.");
			list = new ArrayList<>();
			double sum=0;
			
			ArrayList<String> oplist = new ArrayList<>();
	        String line1 = null;
	        Set<String> lines = new HashSet<String>();
	        int count = 0;

	        try {
	            FileReader fileReader = new FileReader("Work//opcode-" + fileName[0] + ".asm");
	            FileWriter fileWriter2 = new FileWriter("Work//bigram-" + fileName[0] + ".bg");


	            BufferedReader bufferedReader = new BufferedReader(fileReader);
	            

	                while((line1 = bufferedReader.readLine()) != null) {
	                	if(lines.add(line1))
	                		list.add(line1);

	                	oplist.add(line1);
	                }
	            
	            count = list.size();
	            for(int i=0;i<count;i++) {
	            	for(int j=0;j<count;j++) {
	            		table.put(list.get(i), list.get(j), 0.0);
	            	}
	            }
	            
	            for(int i=0;i<oplist.size()-1;i++) {
	            	table.put(oplist.get(i), oplist.get(i+1), table.get(oplist.get(i), oplist.get(i+1))+1);
	            }
	            
	            for(int i=0;i<count;i++) {
	            	sum = 0;
	            	for(int j=0;j<count;j++) {
	            		sum = sum + table.get(list.get(i), list.get(j));
	            	}
	            	if(sum!=0)
		            	for(int j=0;j<count;j++) {
		            		table.put(list.get(i), list.get(j), table.get(list.get(i), list.get(j))/sum);
		            	}
	            }
	            ///////////////////////////////////////////////////////
	            for(int j=0;j<count;j++) {
            		if(j!=count-1)
            			fileWriter2.write(list.get(j) + " ");
            		else
            			fileWriter2.write(list.get(j) + "\n");
            	}
	            
	            for(int i=0;i<count;i++) {
	            	for(int j=0;j<count;j++) {
	            		if(j!=count-1)
	            			fileWriter2.write(table.get(list.get(i), list.get(j)).toString() + " ");
	            		else
	            			fileWriter2.write(table.get(list.get(i), list.get(j)).toString());
	            	}
	            	if(i!=count-1)
	            		fileWriter2.write("\n");
	            }

	            System.out.println("Bigram: Done " + count);

	            fileWriter2.flush();
	            fileWriter2.close();
	            bufferedReader.close();
	            fileReader.close();

	        }
	        catch(FileNotFoundException ex) {
	        	System.out.println("Unable to open file '" + fileName + "'");               
	        }
	        catch(IOException ex) {
	        	System.out.println("Error reading file '" + fileName + "'");                
	        }
		}
	}

	public double getMonitorWeight() {
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        return screenSize.getWidth();
    }
	////////////////////////////////////////////////////////////////////////////////
	
	public static String[] getAllLists2(String[] elements, int lengthOfList)
	{
	    //initialize our returned list with the number of elements calculated above
	    

	    //lists of length 1 are just the original elements
	    if(lengthOfList == 1)
	    {
	    	allLists = elements;
	    	return allLists; 
	    }
	    else {
	        //the recursion--get all lists of length 3, length 2, all the way up to 1
	        String[] allTmplists = new String[(int)Math.pow(elements.length, lengthOfList)];

	        //append the sublists to each element
	        int arrayIndex = 0;

	        for(int i = 0; i < elements.length; i++){
	            for(int j = 0; j < allLists.length; j++){
	                //add the newly appended combination to the list
	            	allTmplists[arrayIndex] = elements[i] + allLists[j];
	                arrayIndex++;
	            }
	        }
	        allLists = allTmplists;
	        return allLists;
	    }
	}
	
	public static String[] getAllLists(String[] elements, int lengthOfList)
	{
	    //initialize our returned list with the number of elements calculated above
	    String[] allLists = new String[(int)Math.pow(elements.length, lengthOfList)];

	    //lists of length 1 are just the original elements
	    if(lengthOfList == 1) return elements; 
	    else {
	        //the recursion--get all lists of length 3, length 2, all the way up to 1
	        String[] allSublists = getAllLists(elements, lengthOfList - 1);

	        //append the sublists to each element
	        int arrayIndex = 0;

	        for(int i = 0; i < elements.length; i++){
	            for(int j = 0; j < allSublists.length; j++){
	                //add the newly appended combination to the list
	                allLists[arrayIndex] = elements[i] + allSublists[j];
	                arrayIndex++;
	            }
	        }
	        return allLists;
	    }
	}
	
	
	public void CreateCell() throws Exception {
        Workbook wb = new XSSFWorkbook(); //or new HSSFWorkbook();
        CreationHelper creationHelper = wb.getCreationHelper();
        Sheet sheet = wb.createSheet("OP Code Count");
        
        for(int i=0;i<selectedFile.length;i++)
        {
	        // Create a row and put some cells in it. Rows are 0 based.
	        Row row = sheet.createRow(i);
	        // Create a cell and put a value in it.
	        Cell cell = row.createCell((short)0);
	        cell.setCellValue(1);
	
	        //numeric value
	        row.createCell(1).setCellValue(1.2);
	
	        //plain string value
	        row.createCell(2).setCellValue("This is a string cell");
	
	        //rich text string
	        RichTextString str = creationHelper.createRichTextString("Apache");
	
	        row.createCell(3).setCellValue(str);
	
	        //boolean value
	        row.createCell(4).setCellValue(true);
	
	        //formula
	        row.createCell(5).setCellFormula("SUM(A1:B1)");
	
	        //date
	        CellStyle style = wb.createCellStyle();
	        style.setDataFormat(creationHelper.createDataFormat().getFormat("m/d/yy h:mm"));
	        cell = row.createCell(6);
	        cell.setCellValue(new Date());
	        cell.setCellStyle(style);
	
	        //hyperlink
	        row.createCell(7).setCellFormula("SUM(A1:B1)");
	        cell.setCellFormula("HYPERLINK(\"http://google.com\",\"Google\")");

        }
        // Write the output to a file
        FileOutputStream fileOut = new FileOutputStream("ooxml-cell.xlsx");
        wb.write(fileOut);
        fileOut.close();
        wb.close();
	}
	
	////////////////////////////////////////////////////////////////////////////////
	public static BufferedReader readDataFile(String filename) {
        BufferedReader inputReader = null;
        
        try {
            inputReader = new BufferedReader(new FileReader(filename));
        } catch (FileNotFoundException ex) {
            System.err.println("File not found: " + filename);
        }
        
        return inputReader;
    }
    
    public static Evaluation simpleClassify(Classifier model, Instances trainingSet, Instances testingSet) throws Exception {
        Evaluation validation = new Evaluation(trainingSet);
        
        model.buildClassifier(trainingSet);
        validation.evaluateModel(model, testingSet);
        
        return validation;
    }
    
    public static double calculateAccuracy(FastVector predictions) {
        double correct = 0;
        
        for (int i = 0; i < predictions.size(); i++) {
            NominalPrediction np = (NominalPrediction) predictions.elementAt(i);
            if (np.predicted() == np.actual()) {
                correct++;
            }
        }
        
        return 100 * correct / predictions.size();
    }
    
    public static Instances[][] crossValidationSplit(Instances data, int numberOfFolds) {
        Instances[][] split = new Instances[2][numberOfFolds];
        
        for (int i = 0; i < numberOfFolds; i++) {
            split[0][i] = data.trainCV(numberOfFolds, i);
            split[1][i] = data.testCV(numberOfFolds, i);
        }
        
        return split;
    }
    
	public void dmall() {
		
//		ExportArff();
		// I've commented the code as best I can, at the moment.
        // Comments are denoted by "//" at the beginning of the line.
        
        BufferedReader datafile = readDataFile("Work//weka-malware.arff");
        
        Instances data = null;
		try {
			data = new Instances(datafile);
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
        data.setClassIndex(data.numAttributes() - 1);
        
        // Choose a type of validation split
        Instances[][] split = crossValidationSplit(data, 10);
        
        // Separate split into training and testing arrays
        Instances[] trainingSplits = split[0];
        Instances[] testingSplits  = split[1];
        
        // Choose a set of classifiers
        Classifier[] models = {     new J48(),
                                    new DecisionTable(),
                                    new DecisionStump(),
                                    new BayesianLogisticRegression() };
        
        // Run for each classifier model
//for(int j = 0; j < models.length; j++) {
        int j = 0;
        	switch (comboClassifiers.getSelectedItem().toString()) {
			case "J48":
				j = 0;
				break;
			case "DecisionTable":
				j = 1;
				break;
			case "DecisionStump":
				j = 2;
				break;
			case "BayesianLogisticRegression":
				j = 3;
				break;
			default:
				break;
			}
        	

            // Collect every group of predictions for current model in a FastVector
            FastVector predictions = new FastVector();
            
            // For each training-testing split pair, train and test the classifier
            for(int i = 0; i < trainingSplits.length; i++) {
                Evaluation validation = null;
				try {
					validation = simpleClassify(models[j], trainingSplits[i], testingSplits[i]);
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
                predictions.appendElements(validation.predictions());
                
                // Uncomment to see the summary for each training-testing pair.
//                textArea.append(models[j].toString() + "\n");
                textArea.setText(models[j].toString() + "\n");
//                 System.out.println(models[j].toString());
            }
            
            // Calculate overall accuracy of current classifier on all splits
            double accuracy = calculateAccuracy(predictions);
            
            // Print current classifier's name and accuracy in a complicated, but nice-looking way.
            textArea.append(models[j].getClass().getSimpleName() + ": " + String.format("%.2f%%", accuracy) + "\n=====================\n");
            System.out.println(models[j].getClass().getSimpleName() + ": " + String.format("%.2f%%", accuracy) + "\n=====================");
//}
        
	}
}
